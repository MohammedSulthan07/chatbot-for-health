<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatbot for Health</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .hidden { display: none !important; }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 2rem;
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            position: absolute;
            top: 0;
            left: 0;
            box-sizing: border-box;
        }

        .header-item {
            display: flex;
            align-items: center;
        }

        .header-item.center-text {
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #fff;
            padding: 0.5rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: 500;
            text-align: center;
        }

        .main-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            flex-grow: 1;
            padding-top: 5rem;
        }

        .left-panel {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 250px;
        }
        
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            min-width: 250px;
        }

        .action-button {
            width: 100%;
            max-width: 300px;
            padding: 1.5rem 2rem;
            background-color: transparent;
            border: 4px solid #fff;
            border-radius: 9999px;
            color: #fff;
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }

        .action-button:hover {
            background-color: #fff;
            color: #000;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        .logo-prompt-engineers {
            max-width: 150px;
            height: auto;
        }

        .logo-sih {
            max-width: 100px;
            height: auto;
        }
        
        .logo-forhealth {
            max-width: 80%;
            height: auto;
        }

        .chat-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            height: 100%;
            max-height: 80vh;
            overflow-y: auto;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .chat-container::-webkit-scrollbar {
            display: none;
        }

        .chat-bubble {
            background-color: #1a1a1a;
            color: #fff;
            padding: 1rem;
            border-radius: 1.5rem;
            margin-bottom: 1rem;
            position: relative;
            word-wrap: break-word; /* Ensure text wraps */
        }

        .user-bubble {
            background-color: #2c2c2c;
            align-self: flex-end;
            margin-left: 20%;
            border-bottom-right-radius: 0.5rem;
        }
        
        .bot-bubble {
            background-color: #4a4a4a;
            align-self: flex-start;
            margin-right: 20%;
            border-bottom-left-radius: 0.5rem;
        }

        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1.25rem;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .copy-button:hover {
            opacity: 1;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots span {
            display: inline-block;
            width: 8px;
            height: 8px;
            margin: 0 2px;
            background-color: #fff;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
        .loading-dots span:nth-child(3) { animation-delay: 0s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .speech-star-button {
            background-color: #fff;
            color: #000;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            font-size: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .speech-star-button.listening {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        .speech-message-bubble {
            background-color: #1a1a1a;
            color: #fff;
            padding: 1rem;
            border-radius: 1.5rem;
            margin-bottom: 1rem;
            position: relative;
            max-width: 80%;
            word-wrap: break-word; /* Ensure text wraps */
        }

        .speech-message-bubble.user-message {
            background-color: #2c2c2c;
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 0.5rem;
        }
        
        .speech-message-bubble.bot-message {
            background-color: #4a4a4a;
            align-self: flex-start;
            margin-right: auto;
            border-bottom-left-radius: 0.5rem;
        }
        
        /* Table Styles for Markdown Rendering */
        table {
            border-collapse: collapse;
            margin: 1rem 0;
            width: 100%;
        }
        th, td {
            border: 1px solid #fff;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* List Styles for Markdown Rendering */
        ul, ol {
            margin: 1rem 0 1rem 1.5rem;
            padding-left: 0;
        }
        li {
            margin-bottom: 0.5rem;
        }

        
@media (max-width: 768px) {
    .header {
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-align: center;
        padding: 1rem;
    }

    .header-item.center-text {
        font-size: 1rem;  /* smaller for mobile */
        padding: 0.5rem 1rem;
        max-width: 90%;
        word-wrap: break-word;
    }

    .main-content {
        flex-direction: column;
        padding-top: 6rem;
        justify-content: flex-start;
        align-items: center;
    }

    .left-panel, .right-panel {
        width: 100%;
        text-align: center;
    }

    .right-panel {
        margin-top: 1.5rem;
        gap: 1rem;
    }

    .action-button {
        width: 90%;        /* fit screen width */
        max-width: none;   /* remove desktop limit */
        font-size: 1.5rem; /* slightly smaller on mobile */
        padding: 1rem;
    }

    .logo-forhealth {
        max-width: 70%; /* scale logo */
    }
}


            .main-content {
                flex-direction: column;
                padding-top: 8rem;
                justify-content: flex-start;
            }

            .left-panel, .right-panel {
                flex: none;
                width: 100%;
            }

            .right-panel {
                margin-top: 2rem;
            }
        }
    </style>
</head>
<body>

<div class="container" id="homepage">
    <div class="header">
        <div class="header-item">
            <img src="https://raw.githubusercontent.com/MohammedSulthan07/chatbot-for-health/main/logo.png" alt="Prompt Engineers Logo" class="logo-prompt-engineers" />
        </div>
        <div class="header-item center-text">
            AI-DRIVEN PUBLIC HEALTH CHATBOT FOR DISEASE AWARENESS
        </div>
        <div class="header-item">
            <img src="https://raw.githubusercontent.com/MohammedSulthan07/chatbot-for-health/main/sih_logo.png" alt="SIH Logo" class="logo-sih" />
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel">
            <img src="https://raw.githubusercontent.com/MohammedSulthan07/chatbot-for-health/main/forhealth.png" alt="Chatbot For Health Logo" class="logo-forhealth" />
        </div>
        <div class="right-panel">
            <button id="chat-button" class="action-button">CHAT</button>
            <button id="speak-button" class="action-button">SPEAK</button>
        </div>
    </div>
</div>

<div class="container hidden" id="chat-page">
    <div class="header">
        <div class="header-item">
            <h1 class="text-4xl font-bold">HISTORY</h1>
            <button id="chat-back-button" class="ml-4 text-3xl">&#8592;</button>
        </div>
        <div class="header-item">
            <button id="chat-home-button" class="action-button px-4 py-2 text-xl">Back</button>
        </div>
    </div>

    <div class="main-content flex-col items-start p-4">
        <div id="chat-history" class="chat-container flex flex-col-reverse w-full" style="height: 60vh;">
            <div class="chat-bubble bot-bubble">
                <pre class="whitespace-pre-wrap">HELLO I AM A AI-DRIVEN PUBLIC HEALTH CHATBOT FOR DISEASE AWARENESS</pre>
            </div>
        </div>
    </div>
    <div class="w-full max-w-4xl px-4 py-2">
        <div class="flex items-center bg-gray-800 rounded-full px-6 py-3">
            <input id="chat-input" type="text" placeholder="TYPE HERE ......" class="flex-grow bg-transparent outline-none text-white text-lg">
            <button id="send-button" class="bg-white text-gray-800 w-12 h-12 rounded-full font-bold ml-4 text-2xl">&gt;</button>
        </div>
    </div>
</div>

<div class="container hidden" id="speak-page">
    <div class="header">
        <div class="header-item">
            <button id="speak-home-button" class="action-button px-4 py-2 text-xl">Back</button>
        </div>
    </div>
    <div class="main-content flex-col justify-end items-center">
        <div id="speech-messages-display" class="chat-container flex flex-col-reverse w-full mb-8" style="flex-grow: 1;">
            <div class="speech-message-bubble bot-message">
                <span>Hello, I am a voice-enabled public health chatbot. How can I help you today?</span>
            </div>
        </div>
        <button id="speech-star-button" class="speech-star-button">
            <span>&#127908;</span>
        </button>
    </div>
</div>

<script>
    // API URL is a constant and doesn't need template literals
    const API_URL = "https://router.huggingface.co/v1/chat/completions";

    function showPage(pageId) {
        document.getElementById('homepage').classList.add('hidden');
        document.getElementById('chat-page').classList.add('hidden');
        document.getElementById('speak-page').classList.add('hidden');
        document.getElementById(pageId).classList.remove('hidden');
    }

    document.addEventListener('DOMContentLoaded', () => {
        showPage('homepage');

        // Fetch the API key from the keys.json file first
        fetch('keys.json')
            .then(response => {
                if (!response.ok) {
                    // FIX: Replaced single quotes with backticks for template literal
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // The prompt requested not to fix Example 2, which is the token variable creation.
                // It's technically correct but less conventional.
                const HF_TOKEN = "hf_" + data.api_key;
                
                // Now that the token is available, set up the chatbot and speechbot
                setupChatbot(HF_TOKEN);
                setupSpeechbot(HF_TOKEN);

                // Attach event listeners for page navigation
                document.getElementById('chat-button').addEventListener('click', () => showPage('chat-page'));
                document.getElementById('speak-button').addEventListener('click', () => showPage('speak-page'));
                document.getElementById('chat-back-button').addEventListener('click', () => showPage('homepage'));
                document.getElementById('chat-home-button').addEventListener('click', () => showPage('homepage'));
                // Changed speak-back-button to speak-home-button for consistency with the new ID in HTML
                document.getElementById('speak-home-button').addEventListener('click', () => showPage('homepage')); 
            })
            .catch(error => {
                console.error('Error fetching API key:', error);
                // Removed inline CSS for better readability in the warning message
                const errorMessage = document.createElement('div');
                errorMessage.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: #ff4d4d;
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    z-index: 1000;
                    text-align: center;
                `;
                errorMessage.textContent = 'Failed to load API key. Please ensure keys.json is present and correctly formatted.';
                document.body.appendChild(errorMessage);
                setTimeout(() => {
                    document.body.removeChild(errorMessage);
                }, 5000);
            });
    });

    // --- Markdown Formatting Functions ---
    // Simple safe-HTML escape
    function escapeHtml(s){
        return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }

    // Convert inline markdown-ish formatting
    function inlineFormat(s){
        // FIX: Updated regex for code block to only target backticks
        s = s.replace(/`([^`]+)`/g, (m, p1) => '<code>' + escapeHtml(p1) + '</code>');
        // FIX: Updated regex for bold (**text** or __text__)
        s = s.replace(/\*\*([^\*]+)\*\*|__([^_]+)__/g, (m, p1, p2) => '<strong>' + escapeHtml(p1 || p2) + '</strong>');
        // FIX: Updated regex for italic (*text* or _text_) - checks not preceded by an asterisk/underscore
        s = s.replace(/(?<!\*)\*([^\*]+)\*(?!\*)|(?<!\_)\_([^_]+)\_(?!\_)/g, (m, p1, p2) => '<em>' + escapeHtml(p1 || p2) + '</em>');
        // links [text](url)
        s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m,p1,p2) => {
            const text = escapeHtml(p1);
            const url = escapeHtml(p2);
            return '<a href="'+ url +'" target="_blank" rel="noopener noreferrer">'+ text +'</a>';
        });
        return s;
    }

    // Detect table block (lines containing | ) and render HTML table
    function parseTableBlock(lines){
        // lines: array of strings (unescaped)
        const rows = lines.map(l => {
            // remove leading/trailing | and split
            const trimmed = l.trim().replace(/^\|/,'').replace(/\|$/,'');
            return trimmed.split('|').map(cell => cell.trim());
        });

        // If second row is a separator of dashes (---), treat as header
        let header = null;
        if(rows.length >= 2 && rows[1].every(cell => /^:?-{2,}:?$/.test(cell))){
            header = rows[0];
            rows.splice(0,2); // remove header row and separator row
        }

        let html = '<div style="overflow:auto"><table>';
        if(header){
            html += '<thead><tr>' + header.map(h => '<th>' + escapeHtml(h) + '</th>').join('') + '</tr></thead>';
        }
        html += '<tbody>';
        rows.forEach(r => {
            html += '<tr>' + r.map(c => '<td>' + inlineFormat(escapeHtml(c)) + '</td>').join('') + '</tr>';
        });
        html += '</tbody></table></div>';
        return html;
    }

    // Main block parser: split by blank lines, detect block types
    function parseToHtml(raw){
        if(!raw) return '<p class="muted" style="color:#6b7280">Nothing to preview â€” paste text in the left pane.</p>';
        // FIX: Corrected regex for newline replacement
        const lines = raw.replaceAll('\r\n','\n').split(/\n/);
        const blocks = [];
        let cur = [];
        // group lines into blocks by blank lines
        for(let i=0;i<lines.length;i++){
            const line = lines[i];
            if(line.trim() === ''){
                if(cur.length) { blocks.push(cur); cur = []; }
            } else {
                cur.push(line);
            }
        }
        if(cur.length) blocks.push(cur);

        const out = blocks.map(block => {
            // If block looks like a table: most lines contain '|' and at least 1 line has leading/trailing | or pipes count >=1
            const pipeCount = block.reduce((acc, l) => acc + (l.includes('|') ? 1:0), 0);
            if(pipeCount >= Math.ceil(block.length / 2) && block.every(l => l.trim().includes('|'))){
                return parseTableBlock(block);
            }

            // If block is a single-line heading like ### or ####
            if(block.length === 1){
                const line = block[0].trim();
                // ATX headings: #, ##, ###
                const m = line.match(/^(#{1,6})\s+(.*)$/);
                if(m){
                    const level = m[1].length;
                    const content = inlineFormat(escapeHtml(m[2]));
                    return '<h' + level + '>' + content + '</h' + level + '>';
                }
                // If line starts with "1. " or "- " or "* " it will be handled below
            }

            // If block is a list (all lines start with - or * or numeric)
            const allList = block.every(l => /^\s*([-*]\s+|[0-9]+\.\s+)/.test(l));
            if(allList){
                // detect ordered vs unordered:
                const firstIsOrdered = /^\s*[0-9]+\.\s+/.test(block[0]);
                if(firstIsOrdered){
                    const items = block.map(l => l.replace(/^\s*[0-9]+\.\s+/, ''));
                    return '<ol>' + items.map(it => '<li>' + inlineFormat(escapeHtml(it)) + '</li>').join('') + '</ol>';
                } else {
                    const items = block.map(l => l.replace(/^\s*[-*]\s+/, ''));
                    return '<ul>' + items.map(it => '<li>' + inlineFormat(escapeHtml(it)) + '</li>').join('') + '</ul>';
                }
            }

            // Otherwise treat as one or several paragraphs (preserve single-line breaks inside block)
            // Join lines with spaces when previous line does not end with two spaces
            const paragraphText = block.map(l => l.trim()).join(' ');
            return '<p>' + inlineFormat(escapeHtml(paragraphText)) + '</p>';
        });

        // Post-process: convert occurrences of lines starting with "### 1." or "### 2." etc to H3 lists if user included numbered titles
        return out.join('\n\n');
    }

    // --- Shared Helper Functions ---
    // Removed commented-out formatMessage function

    function copyToClipboard(text, buttonElement) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            document.execCommand('copy');
            buttonElement.textContent = 'âœ…';
            buttonElement.title = 'Copied!';
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            buttonElement.textContent = 'âŒ';
            buttonElement.title = 'Copy failed';
        }
        setTimeout(() => {
            buttonElement.textContent = 'ðŸ“‹';
            buttonElement.title = 'Copy text';
        }, 2000);
        document.body.removeChild(textArea);
    }

    // --- Chatbot Logic ---
    function setupChatbot(HF_TOKEN) {
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const chatHistory = document.getElementById('chat-history');

        function createChatBubble(message, isUser) {
            const bubble = document.createElement('div');
            bubble.classList.add('chat-bubble');
            if (isUser) {
                bubble.classList.add('user-bubble');
            } else {
                bubble.classList.add('bot-bubble');
            }

            const messageContent = document.createElement('span');
            messageContent.innerHTML = parseToHtml(message);
            bubble.appendChild(messageContent);

            if (!isUser) {
                const copyButton = document.createElement('button');
                copyButton.classList.add('copy-button');
                copyButton.textContent = 'ðŸ“‹';
                copyButton.title = 'Copy text';
                copyButton.onclick = () => copyToClipboard(message, copyButton);
                bubble.appendChild(copyButton);
            }

            // Using prepend to add the new message to the top of the flex-direction: column-reverse container
            chatHistory.prepend(bubble); 
            // FIX: Removed this line as the flexbox style handles the scroll view correctly (latest messages appear at the bottom of the visible area)
            // chatHistory.scrollTop = chatHistory.scrollHeight; 
        }

        async function sendMessage() {
            const userMessage = chatInput.value.trim();
            if (userMessage === '') return;

            createChatBubble(userMessage, true);
            chatInput.value = '';

            const thinkingBubble = document.createElement('div');
            thinkingBubble.classList.add('chat-bubble', 'bot-bubble', 'loading-dots-container');
            thinkingBubble.innerHTML = `
                <div class="loading-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatHistory.prepend(thinkingBubble);

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        // FIX: Corrected template literal usage for Authorization header
                        "Authorization": `Bearer ${HF_TOKEN}`, 
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        messages: [{
                            "role": "system",
                            "content": "You are a specialized AI-DRIVEN PUBLIC HEALTH CHATBOT FOR DISEASE AWARENESS. Your purpose is strictly limited to providing information on public health and diseases. If a user asks a question that is not directly related to public health or diseases, you must respond only with the exact phrase 'Sorry, I cannot answer that question as it is not related to my purpose.' Do not provide any other information or elaboration, even if it is a general knowledge topic. If the question is health-related, provide a helpful and informative response."
                        }, {
                            "role": "user",
                            "content": userMessage
                        }],
                        "model": "openai/gpt-oss-20b:fireworks-ai",
                        "stream": false
                    })
                });

                chatHistory.removeChild(thinkingBubble);

                if (!response.ok) {
                    // FIX: Replaced single quotes with backticks for template literal
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                let botMessage = data.choices[0].message.content;

                // Checking for the exact phrase is sufficient
                if (!botMessage.includes("Sorry, I cannot answer that question")) {
                    // FIX: Removed extra newlines, replaced with just one
                    botMessage += "\n\nThis is a chatbot for general awareness. Please consult a qualified healthcare professional for medical advice.";
                }
                
                createChatBubble(botMessage, false);

            } catch (error) {
                chatHistory.removeChild(thinkingBubble);
                console.error('Error:', error);
                createChatBubble('Oops, something went wrong. Please try again later.', false);
            }
        }

        sendButton.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
    }

    // --- Speech Chat Logic ---
    function setupSpeechbot(HF_TOKEN) {
        const speechStarButton = document.getElementById('speech-star-button');
        const speechMessagesDisplay = document.getElementById('speech-messages-display');
        let speechChatHistory = [];
        let isListening = false;
        let recognition;
        let currentUtterance = null;
        let botIsSpeaking = false;
        let femaleVoice = null;

        function findFemaleVoice() {
            const voices = window.speechSynthesis.getVoices();
            femaleVoice = voices.find(voice => voice.name.toLowerCase().includes('female') && (voice.lang.includes('en-US') || voice.lang.includes('en-GB'))) || 
                         voices.find(voice => voice.name.toLowerCase().includes('female')) ||
                         voices.find(voice => voice.name.toLowerCase().includes('zira') || voice.name.toLowerCase().includes('ava'));
        }

        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = findFemaleVoice;
            findFemaleVoice();
        }

        function addSpeechMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('speech-message-bubble', sender + '-message');
            
            const contentSpan = document.createElement('span');
            contentSpan.innerHTML = parseToHtml(text);
            messageDiv.appendChild(contentSpan);

            if (sender === 'bot') {
                const copyButton = document.createElement('button');
                copyButton.classList.add('copy-button');
                copyButton.textContent = 'ðŸ“‹';
                copyButton.title = 'Copy text';
                copyButton.onclick = () => copyToClipboard(text, copyButton);
                messageDiv.appendChild(copyButton);
            }

            speechMessagesDisplay.prepend(messageDiv);
            // FIX: Removed this line as the flexbox style handles the scroll view correctly
            // speechMessagesDisplay.scrollTop = speechMessagesDisplay.scrollHeight;
        }

        async function fetchSpeechBotReply(userInput) {
            const thinkingBubble = document.createElement('div');
            thinkingBubble.classList.add('speech-message-bubble', 'bot-message', 'loading-dots-container');
            thinkingBubble.innerHTML = `
                <div class="loading-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            speechMessagesDisplay.prepend(thinkingBubble);

            speechChatHistory.push({ role: "user", content: userInput });

            const messages = [{
                "role": "system",
                "content": "You are a specialized AI-DRIVEN PUBLIC HEALTH CHATBOT FOR DISEASE AWARENESS. Your purpose is strictly limited to providing information on public health and diseases. If a user asks a question that is not directly related to public health or diseases, you must respond only with the exact phrase 'Sorry, I cannot answer that question as it is not related to my purpose.' Do not provide any other information or elaboration, even if it is a general knowledge topic. If the question is health-related, provide a helpful and informative response."
            }, ...speechChatHistory];

            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    // FIX: Corrected template literal usage for Authorization header
                    headers: { "Authorization": `Bearer ${HF_TOKEN}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "openai/gpt-oss-20b:fireworks-ai", messages: messages, stream: false })
                });
                
                speechMessagesDisplay.removeChild(thinkingBubble);

                if (!response.ok) {
                    // FIX: Replaced single quotes with backticks for template literal
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (data?.choices?.[0]?.message) {
                    let botReply = data.choices[0].message.content;
                    if (!botReply.includes("Sorry, I cannot answer that question")) {
                        botReply += "\n\nThis is a chatbot for general awareness. Please consult a qualified healthcare professional for medical advice.";
                    }
                    speechChatHistory.push({ role: "assistant", content: botReply });
                    addSpeechMessage(botReply, "bot");
                    speak(botReply);
                } else {
                    addSpeechMessage("ðŸ¤– No response from the model.", "bot");
                }
            } catch (error) {
                speechMessagesDisplay.removeChild(thinkingBubble);
                console.error(error);
                addSpeechMessage("âŒ Error connecting to the API.", "bot");
            }
        }
        
        function speak(text) {
            if (currentUtterance) window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            if (femaleVoice) utterance.voice = femaleVoice;
            currentUtterance = utterance;
            utterance.onstart = () => { botIsSpeaking = true; };
            utterance.onend = () => { botIsSpeaking = false; currentUtterance = null; };
            window.speechSynthesis.speak(utterance);
        }

        function startSpeechRecognition() {
            if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
                addSpeechMessage("Your browser does not support Speech Recognition.", "bot");
                return;
            }

            // Check if recognition is already running and stop it before starting a new one
            if (recognition && isListening) {
                recognition.stop();
            }

            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            
            recognition.onstart = () => { isListening = true; speechStarButton.classList.add('listening'); };
            recognition.onend = () => { isListening = false; speechStarButton.classList.remove('listening'); };
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                // FIX: Replaced single quotes with backticks for template literal
                addSpeechMessage(`âŒ Speech Error: ${event.error}`, "bot"); 
            };
            recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                if (speechResult) {
                    addSpeechMessage(speechResult, "user");
                    fetchSpeechBotReply(speechResult);
                }
            };
            recognition.start();
        }

        speechStarButton.addEventListener('click', () => {
            if (botIsSpeaking) {
                window.speechSynthesis.cancel();
                botIsSpeaking = false;
                currentUtterance = null;
            } else if (isListening) {
                recognition.stop();
            } else {
                startSpeechRecognition();
            }
        });
    }
</script>

</body>
</html>
